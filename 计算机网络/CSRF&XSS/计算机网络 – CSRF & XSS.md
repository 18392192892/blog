## 计算机网络 -- CSRF & XSS

@(Interview)

网络攻击方式这两种算是比较出名的了

分别详细介绍一下这两种攻击

### 一丶CSRF

#### 1. 什么是CSRF

`CSRF`（Cross-site request forgery）**跨站请求伪造**：攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。**利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的**。

一个典型的`CSRF`攻击有如下的流程：

- 受害者登录`a.com`，并保留了登录凭证（Cookie）
- 攻击者引诱受害者访问了`b.com`
- `b.com`向`a.com`发送了一个请求：`a.com/act=xx`
- `a.com`接收到请求后，对请求进行验证，并确认是受害者的凭证，误以为是受害者自己发送的请求
- `a.com`以受害者的名义执行了`act=xx`
- 攻击完成，攻击者在受害者不知情的情况下，冒充受害者，让a.com执行了自己定义的操作。

#### 2. 常见的攻击类型

`CSRF` 有多种攻击方式

##### (1). GET类型的CSRF

`GET`类型是最普通最简单的方法

只需要一个 `HTTP` 请求，一般会这样利用：
> ` <img src="http://bank.example/withdraw?amount=10000&for=hacker" > `

在受害者访问含有这个`img`的页面后。浏览器会自动向`http://bank.example/withdraw?account=xiaoming&amount=10000&for=hacker`，发出一次`HTTP`请求。`bank.example`就会收到包含受害者登录信息的一次跨域请求。

##### (2). POST类型的CSRF

这种类型的`CSRF`利用起来通常使用的是一个自动提交的表单，如：

```
 <form action="http://bank.example/withdraw" method=POST>
    <input type="hidden" name="account" value="xiaoming" />
    <input type="hidden" name="amount" value="10000" />
    <input type="hidden" name="for" value="hacker" />
</form>
<script> document.forms[0].submit(); </script> 
```
访问该页面后，表单会自动提交，相当于模拟用户完成了一次 `POST` 操作。

`POST` 类型的攻击通常比 `GET` 要求更加严格一点，但仍并不复杂。任何个人网站、博客，被黑客上传页面的网站都有可能是发起攻击的来源，后端接口不能将安全寄托在仅允许 `POST` 上面。

##### (3). 链接类型的CSRF

链接类型的 `CSRF` 并不常见，比起其他两种用户打开页面就中招的情况，这种需要用户点击链接才会触发。这种类型通常是在论坛中发布的图片中嵌入恶意链接，或者以广告的形式诱导用户中招，攻击者通常会以比较夸张的词语诱骗用户点击，例如：

```
 <a href="http://test.com/csrf/withdraw.php?amount=1000&for=hacker" taget="_blank">
  震惊！！
 <a/>
```
由于之前用户登录了信任的网站A，并且保存登录状态，只要用户主动访问上面的这个PHP页面，则表示攻击成功。

#### 3. CSRF的特点

- 攻击一般发起在第三方网站，而不是被攻击的网站。被攻击的网站无法防止攻击发生。
- 攻击利用受害者在被攻击网站的登录凭证，冒充受害者提交操作，而不是直接窃取数据。
- 整个过程攻击者并不能获取到受害者的登录凭证，仅仅是“冒用”。
- 跨站请求可以用各种方式：图片`URL`、超链接、`CORS`、`Form`提交等等。部分请求方式可以直接嵌入在第三方论坛、文章中，难以进行追踪。


#### 4. 防护策略

这样一个危险的攻击，防御措施是必不可少的

有这样几种方法防护：

- 验证码
- 同源检测
- Samesite Cookie
- 双重`cookie`
- Token

##### (1). 验证码

验证码被认为是对抗 `CSRF` 攻击最简洁而有效的防御方法。

从上述示例中可以看出，`CSRF` 攻击往往是在用户不知情的情况下构造了网络请求。而验证码会强制用户必须与应用进行交互，才能完成最终请求。因为通常情况下，验证码能够很好地遏制 `CSRF` 攻击。

但验证码并不是万能的，因为出于用户考虑，**不能给网站所有的操作都加上验证码**。因此，验证码只能作为防御 `CSRF` 的一种辅助手段，而不能作为最主要的解决方案。

##### (2). 同源检测

既然`CSRF`大多来自第三方网站，那么我们只需要禁止外域（或者不受信任的域名）对我们发起请求

那么问题来了，我们如何判断请求是否来自外域呢？

在`HTTP`协议中，每一个异步请求都会携带两个`Header`，用于标记来源域名：
- `Origin Header`
- `Referer Header`

这两个 `Header` 在浏览器发起请求时，大多数情况会自动带上，**并且不能由前端自定义内容**。 服务器可以通过解析这两个 `Header` 中的域名，确定请求的来源域。

**使用`Origin Header`确定来源域名**

在部分与 `CSRF` 有关的请求中，请求的 `Header` 中会携带 `Origin` 字段。字段内包含请求的域名，也就是 `CORS` 的原理

如果每次的请求都有`Origin`存在，那么直接使用`Origin`中的字段确认来源域名就可以

但是 `Origin` 在以下两种情况下并不存在：

- **IE11同源策略：**IE 11 不会在跨站CORS请求上添加`Origin`标头，`Referer` 头将仍然是唯一的标识。**最根本原因是因为IE 11对同源的定义和其他浏览器有不同**。
- **302重定向：**在302重定向之后 `Origin` 不包含在重定向的请求中，因为 `Origin` 可能会被认为是其他来源的敏感信息。对于302重定向的情况来说都是定向到新的服务器上的 URL，因此浏览器不想将 `Origin` 泄漏到新的服务器上。

**使用`Referer Header`确定来源域名**

根据 `HTTP` 协议，在 `HTTP` 头中有一个字段叫 `Referer`，记录了该 `HTTP` 请求的来源地址。
对于 `Ajax` 请求，图片和 `script` 等资源请求，`Referer` 为发起请求的页面地址。对于页面跳转，`Referer` 为打开页面历史记录的前一个页面地址。因此我们使用 `Referer` 中链接的`Origin` 部分可以得知请求的来源域名。

**无法确认来源域名情况**

如果`Origin`和`Referer`头文件不存在时该怎么办？如果`Origin`和`Referer`都不存在，建议直接进行阻止

##### (3). Samesite Cookie

防止 `CSRF` 攻击的办法已经有上面的预防措施。为了从源头上解决这个问题，`Google` 起草了一份草案来改进 `HTTP` 协议，那就是为 `Set-Cookie` 响应头新增 `Samesite` 属性，它用来标明这个 `Cookie` 是个“同站 `Cookie`”，同站 `Cookie` 只能作为第一方 `Cookie`，不能作为第三方 `Cookie`，`Samesite` 有两个属性值，分别是 `Strict` 和 `Lax`，下面分别讲解：

**Samesite=Strict**

这种称为严格模式，表明这个 `Cookie` 在任何情况下都不可能作为第三方 `Cookie`，绝无例外。比如说 `b.com` 设置了如下 `Cookie`：
```
Set-Cookie: foo=1; Samesite=Strict
Set-Cookie: bar=2; Samesite=Lax
Set-Cookie: baz=3
```
我们在 `a.com` 下发起对 `b.com` 的任意请求，`foo` 这个 `Cookie` 都不会被包含在 `Cookie` 请求头中，但 `bar` 会。举个实际的例子就是，假如淘宝网站用来识别用户登录与否的 `Cookie` 被设置成了 `Samesite=Strict`，那么用户从百度搜索页面甚至天猫页面的链接点击进入淘宝后，淘宝都不会是登录状态，因为淘宝的服务器不会接受到那个 `Cookie`，其它网站发起的对淘宝的任意请求都不会带上那个 `Cookie`。

**Samesite=Lax**

这种称为宽松模式，比 `Strict` 放宽了点限制：假如这个请求是这种请求（改变了当前页面或者打开了新页面）且同时是个GET请求，则这个Cookie可以作为第三方Cookie。比如说 b.com设置了如下Cookie：

```
Set-Cookie: foo=1; Samesite=Strict
Set-Cookie: bar=2; Samesite=Lax
Set-Cookie: baz=3
```
当用户从 `a.com` 点击链接进入 `b.com` 时，`foo` 这个 `Cookie` 不会被包含在 `Cookie` 请求头中，但 `bar` 和 `baz` 会，也就是说用户在不同网站之间通过链接跳转是不受影响了。但假如这个请求是从 `a.com` 发起的对 `b.com` 的异步请求，或者页面跳转是通过表单的 `post` 提交触发的，则 `bar` 也不会发送。

**该如何使用SamesiteCookie**

如果 `SamesiteCookie` 被设置为`Strict`，浏览器在任何跨域请求中都不会携带 `Cookie`，新标签重新打开也不携带，所以说 `CSRF` 攻击基本没有机会。

但是跳转子域名或者是新标签重新打开刚登陆的网站，之前的`Cookie`都不会存在。尤其是有登录的网站，那么我们新打开一个标签进入，或者跳转到子域名的网站，**都需要重新登录**。对于用户来讲，可能体验不会很好。

如果`SamesiteCookie`被设置为`Lax`，那么其他网站通过页面跳转过来的时候可以使用 `Cookie`，可以保障外域连接打开页面时用户的登录状态。但相应的，其安全性也比较低。

**另外一个问题是`Samesite`的兼容性不是很好**，现阶段除了从新版`Chrome`和`Firefox`支持以外，Safari以及iOS Safari都还不支持，现阶段看来暂时还不能普及。

而且，`SamesiteCookie`目前有一个致命的缺陷：**不支持子域**。例如，种在`topic.a.com`下的 `Cookie`，并不能使用`a.com`下种植的 `SamesiteCookie`。
这就导致了当我们网站有多个子域名时，不能使用 `SamesiteCookie`在主域名存储用户登录信息。每个子域名都需要用户重新登录一次。
总之，`SamesiteCookie` 是一个可能替代同源验证的方案，但目前还并不成熟，其应用场景有待观望。

##### (4). 双重cookie验证

那么另一种防御措施是使用双重提交 `Cookie`。利用 `CSRF` 攻击不能获取到用户 `Cookie` 的特点，我们可以要求 `Ajax` 和表单请求携带一个 `Cookie` 中的值。

双重Cookie采用以下流程：
- 在用户访问网站页面时，向请求域名注入一个`Cookie`，内容为随机字符串（例如`csrfcookie=v8g9e4ksfhw`）。
- 在前端向后端发起请求时，取出`Cookie`，并添加到 `URL` 的参数中（接上例`POST` `https://www.a.com/comment?csrfcookie=v8g9e4ksfhw`）。
- 后端接口验证Cookie中的字段与URL参数中的字段是否一致，不一致则拒绝。

这种方法还是不要用，太傻逼了


##### (5). Token

因为`CSRF`的原理是浏览器会自动携带`Cookie`访问接口，所以我们要做的是不适用`Cookie`就好了，通过`token`来验证用户的状态，这样可以从根上解决这个问题


### 二丶XSS

#### 1. 什么是XSS

`XSS`，即 `Cross Site Script`，中译是**跨站脚本攻击**。其原本缩写是 `CSS`，但为了和层叠样式表(Cascading Style Sheet)有所区分，因而在安全领域叫做 `XSS`。

XSS 的本质是：恶意代码未经过滤，与网站正常的代码混在一起，**浏览器无法分辨哪些脚本是可信的**，导致恶意脚本被执行。

而由于直接在用户的终端执行，恶意代码能够**直接获取用户的信息**，或者利用这些信息冒充用户向网站发起攻击者定义的请求。

在部分情况下，由于输入的限制，注入的恶意脚本比较短。但可以通过引入外部的脚本，并由浏览器执行，来完成比较复杂的攻击策略。

#### 2. XSS分类

根据攻击的来源，可以分为**存储型**，**反射性**，**DOM型**三种

| 类型      |     存储区 |   插入点   |
| :--------: | :--------:| :------: |
| 存储型    |  后端数据库 |  HTML  |
| 反射性    |  URL |  HTML  |
| DOM型    |   后端数据库/前端存储/URL |  前端 JavaScrip  |

- **存储区**：恶意代码存放的位置
- **插入点**：由谁取得恶意代码，并插入到网页上

##### (1). 存储型 XSS

存储型 XSS 的攻击步骤：

1. 攻击者将恶意代码提交到目标网站的数据库中。
2. 用户打开目标网站时，网站服务端将恶意代码从数据库取出，拼接在 `HTML` 中返回给浏览器
3. 用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。
4. 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。

这种攻击常见于带有**用户保存数据**的网站功能，如论坛发帖、商品评论、用户私信等。


##### (2). 反射型 XSS

反射型 XSS 的攻击步骤：

1. 攻击者构造出特殊的 URL，其中包含恶意代码。
2. 用户打开带有恶意代码的 URL 时，网站服务端将恶意代码从 URL 中取出，拼接在 HTML 中返回给浏览器。
3. 用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。
4. 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。

反射型 `XSS` 跟存储型 `XSS` 的区别是：存储型 `XSS` 的恶意代码存在**数据库**里，反射型 XSS 的恶意代码存在 **URL** 里。

反射型 XSS 漏洞常见于通过 URL 传递参数的功能，如网站搜索、跳转等。
由于需要用户主动打开恶意的 URL 才能生效，攻击者往往会结合多种手段诱导用户点击。

##### (3). DOM 型 XSS

DOM 型 XSS 的攻击步骤：

1. 攻击者构造出特殊的 URL，其中包含恶意代码。
2. 用户打开带有恶意代码的 URL。
3. 用户浏览器接收到响应后解析执行，前端 JavaScript 取出 URL 中的恶意代码并执行。
4. 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。

DOM 型 XSS 跟前两种 XSS 的区别：DOM 型 XSS 攻击中，取出和执行恶意代码由**浏览器端**完成，属于前端 JavaScript 自身的安全漏洞，而其他两种 XSS 都属于服务端的安全漏洞。

#### 3. XSS的防范

通过前面的接受可以得知，XSS 攻击由两大要素：

1. 攻击者提交恶意代码
2. 浏览器执行恶意代码

##### (1). 从攻击者提交恶意代码方向预防

针对第一个要素，我们可以在后端写入数据库前，对输入进行过滤，但是这样的方法不是很理想，因为我们并不清楚内容要输出到哪里，在不同的位置，所需要的编码是不同的。

所以输入侧过滤能够在某些情况下解决特定的 `XSS` 问题，但会引入很大的**不确定性和乱码问题**。在防范 `XSS` 攻击时应避免此类方法。

当然，对于明确的输入类型，例如数字、`URL`、电话号码、邮件地址等等内容，进行输入过滤还是必要的。

##### (2). 从浏览器执行恶意代码方向预防

既然输入过滤并非完全可靠，我们就需要通过 **防止浏览器执行恶意代码** 来防范 XSS，这部分分为两类，**防止 HTML 中出现注入** 和 **防止 JavaScript 执行时，执行恶意代码**

**预防存储型和反射型 XSS 攻击**

存储型和反射型 `XSS` 都是在服务端取出恶意代码后，插入到响应 `HTML` 里的，攻击者刻意编写的“数据”被内嵌到“代码”中，被浏览器所执行。

我们分为两种方式：
- 对 HTML 做充分转译
- 改成纯前端渲染，把代码和数据分隔开

**纯前端渲染**

纯前端渲染的过程：

1. 浏览器先加载一个静态 HTML，此 HTML 中不包含任何跟业务相关的数据。
2. 然后浏览器执行 HTML 中的 JavaScript。
3. JavaScript 通过 Ajax 加载业务数据，调用 DOM API 更新到页面上。

在纯前端渲染中，我们会明确的告诉浏览器：下面要设置的内容是文本（`.innerText`），还是属性（`.setAttribute`），还是样式（`.style`）等等。浏览器不会被轻易的被欺骗，执行预期外的代码了。不拼接`HTML`是个很有效的方法 

在很多内部、管理系统中，采用纯前端渲染是非常合适的。但对于性能要求高，或有 `SEO` 需求的页面，我们仍然要面对拼接 `HTML` 的问题。


**转译 HTML**
如果拼接 HTML 是必要的，就需要采用合适的转移库，对 `HTML` 模板各处插入点进行充分的转义。


常用的模板引擎，如 `doT.js`、`ejs`、`FreeMarker` 等，对于 `HTML` 转义通常只有一个规则，就是把 `& < > " ' /` 这几个字符转义掉，确实能起到一定的 XSS 防护作用，但并不完善。

所以要完善 XSS 防护措施，我们要使用更完善更细致的转义策略。


**预防 DOM 型 XSS 攻击**

`DOM` 型 `XSS` 攻击，实际上就是网站前端 `JavaScript` 代码本身不够严谨，把不可信的数据当作代码执行了。

在使用 `.innerHTML`、`.outerHTML`、`document.write()` 时要特别小心，不要把不可信的数据作为 `HTML` 插到页面上，而应尽量使用 `.textContent`、`.setAttribute()` 等。

`DOM` 中的内联事件监听器，如 `location`、`onclick`、`onerror`、`onload`、`onmouseover` 等，`<a>` 标签的 `href` 属性，`JavaScript` 的 `eval()`、`setTimeout()`、`setInterval()` 等，都能把字符串作为代码运行。如果不可信的数据拼接到字符串中传递给这些 API，很容易产生安全隐患，请务必避免。

##### (3). 总结一下

防御 XSS 攻击有以下几种方式：

- HttpOnly
- 输入检查
- 输出检查
- 转译
- 纯前端页面


##### (4). 最牛逼的方案

从上面可以看出，为了防止它们，要采取很多编程措施，非常麻烦。很多人提出，能不能根本上解决问题，浏览器自动禁止外部注入恶意脚本？

于是就有了这个方法，**网页安全政策**，也就是 `CSP`，下面大概介绍以下`CSP`是什么


#### 4. CSP

##### (1). 简介

`CSP` 的实质就是**白名单制度**，开发者明确告诉客户端，哪些外部资源可以加载和执行，等同于提供白名单。**它的实现和执行全部由浏览器完成，开发者只需提供配置**。

`CSP` 大大增强了网页的安全性。攻击者即使发现了漏洞，也没法注入脚本，除非还控制了一台列入了白名单的可信主机。

两种方法可以启用 `CSP`。一种是通过 `HTTP` 头信息的 `Content-Security-Policy` 的字段，另一种是通过网页的`<meta>`标签


##### (2). 限制选项

`CSP` 提供了很多限制选项，涉及安全的各个方面。

它限制了以下选项：

- script-src：外部脚本
- style-src：样式表
- img-src：图像
- media-src：媒体文件（音频和视频）
- font-src：字体文件
- object-src：插件（比如 `Flash`）
- child-src：框架
- frame-ancestors：嵌入的外部资源（比如`<frame>`、`<iframe>`、`<embed>`和`<applet>`）
- connect-src：`HTTP` 连接（通过 `XHR`、`WebSockets`、`EventSource`等）
- worker-src：`worker`脚本
- manifest-src：`manifest` 文件

还有一个`default-src`的属性，用来设置上面各个选项的默认值
> `Content-Security-Policy: default-src 'self'`

上面代码限制**所有的**外部资源，**都只能从当前域名加载**

如果同时设置某个单项限制（比如 `font-src`）和`default-src`，前者会覆盖后者，即字体文件会采用 `font-src` 的值，其他资源依然采用 `default-src` 的值。

剩下的太多，有兴趣的<a href="http://www.ruanyifeng.com/blog/2016/09/csp.html">点这儿</a>


---

##### 参考：
- <a href="https://juejin.im/post/5bad9140e51d450e935c6d64">https://juejin.im/post/5bad9140e51d450e935c6d64</a>
- <a href="https://juejin.im/entry/5b4b56fd5188251b1a7b2ac1">https://juejin.im/entry/5b4b56fd5188251b1a7b2ac1</a>
- <a href="https://juejin.im/post/5bc009996fb9a05d0a055192">https://juejin.im/post/5bc009996fb9a05d0a055192</a>

---
